name: Feeds Check & Publish

on:
  schedule:
    - cron: "*/30 * * * *"    # every 30 minutes
  workflow_dispatch: {}
  push:
    paths:
      - ".github/workflows/feeds-check.yml"

permissions:
  contents: write

jobs:
  feeds:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Resolve base URL
        id: base
        run: |
          if [[ -f CNAME && -s CNAME ]]; then
            BASE="https://$(cat CNAME | tr -d '[:space:]')"
          else
            # Fallback to GitHub Pages user/org site path
            REPO="${{ github.repository }}"
            OWNER="${REPO%%/*}"
            NAME="${REPO##*/}"
            BASE="https://${OWNER}.github.io/${NAME}"
          fi
          echo "base=${BASE}" >> "$GITHUB_OUTPUT"

      - name: Build endpoint list
        id: endpoints
        run: |
          BASE="${{ steps.base.outputs.base }}"
          cat > /tmp/endpoints.json <<'JSON'
          [
            { "name": "All (RSS)",        "path": "/feed/"               },
            { "name": "All (JSON)",       "path": "/feed.json"           },
            { "name": "Logs (RSS)",       "path": "/logs/feed.xml"       },
            { "name": "Field Notes (RSS)","path": "/field-notes/feed.xml"}
          ]
          JSON

          # External Substack Notes feed (expected to fail until Substack enables it)
          SUBSTACK="https://substack.com/api/v1/notes/rss?publication_id=6660929"

          jq --arg base "$BASE" --arg sub "$SUBSTACK" '
            . as $e |
            ($e | map(. + { url: ($base + .path) })) +
            [ { "name": "Substack Field Notes (external)", "url": $sub } ]
          ' /tmp/endpoints.json > /tmp/endpoints-final.json

      - name: Probe endpoints (curl with UA)
        run: |
          UA="FinchStatusBot/1.0 (+https://fincharchive.com/status/)"
          now="$(date -u +%Y-%m-%dT%H:%M:%SZ)"

          echo '{ "updated_utc": "'$now'", "endpoints": [] }' > /tmp/feeds.json

          jq -c '.[]' /tmp/endpoints-final.json | while read -r row; do
            name=$(jq -r '.name' <<<"$row")
            url=$(jq -r '.url' <<<"$row")

            # Try HEAD first, fall back to GET (some hosts block HEAD)
            code=$(curl -sS -I -L -o /dev/null -w "%{http_code}" -A "$UA" "$url")
            if [[ "$code" -eq 000 || "$code" -ge 400 ]]; then
              code=$(curl -sS -L -o /dev/null -w "%{http_code}" -A "$UA" "$url")
            fi

            jq --arg n "$name" --arg u "$url" --arg c "$code" \
               '.endpoints += [ { "name": $n, "url": $u, "status": ($c|tonumber) } ]' \
               /tmp/feeds.json > /tmp/feeds.json.tmp && mv /tmp/feeds.json.tmp /tmp/feeds.json
          done

          mkdir -p status _data
          cp /tmp/feeds.json status/feeds.json
          # also publish an easy-to-consume copy for Jekyll templates
          cp /tmp/feeds.json _data/feeds-status.json

      - name: Commit results
        run: |
          if ! git diff --quiet -- status/feeds.json _data/feeds-status.json; then
            git config user.name  "HallowayFinch"
            git config user.email "${{ secrets.HF_NOREPLY_EMAIL }}"
            git add status/feeds.json _data/feeds-status.json
            git commit -m "chore(status): update feeds.json (+ _data/feeds-status.json)"
            git push "https://x-access-token:${{ secrets.HF_PAT }}@github.com/${{ github.repository }}.git" HEAD:main
          else
            echo "No changes to commit."
          fi
