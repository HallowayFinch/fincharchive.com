name: Artifacts · Hash & Verify
# Finch Archive · Hash artifacts, update metadata, and verify integrity
#
# Triggers:
# - On push when artifacts or hashing scripts change
# - Nightly at 04:17 UTC
# - Manual run via "Run workflow"
#
# Behavior:
# - Runs scripts/hash_artifacts.py to:
#     - compute/update per-folder metadata.json
#     - update SHA256SUMS.txt files (if used)
# - Verifies all artifacts against metadata.json
# - Writes badges/artifacts.json for status/badging
# - Commits & pushes changes only when files actually change

run-name: "Artifacts · Hash & Verify • ${{ github.event_name }} #${{ github.run_number }}"

on:
  push:
    paths:
      - "artifacts/**"
      - "scripts/hash_artifacts.py"
      - ".github/workflows/artifacts.yml"
  schedule:
    # Nightly verification in a quiet window
    - cron: "17 4 * * *"
  workflow_dispatch: {}

permissions:
  contents: write

env:
  GIT_AUTHOR_NAME:  "HallowayFinch"
  GIT_AUTHOR_EMAIL: ${{ secrets.HF_NOREPLY_EMAIL }}
  HF_PAT:           ${{ secrets.HF_PAT }}

# Queue artifact jobs per-branch; do not cancel in-flight runs.
concurrency:
  group: finch-artifacts-${{ github.ref }}
  cancel-in-progress: false

jobs:
  artifacts:
    runs-on: ubuntu-latest
    timeout-minutes: 20

    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          persist-credentials: false

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      # 1) Hash & index artifacts (idempotent)
      - name: Compute hashes & metadata (idempotent)
        run: |
          set -euo pipefail
          python scripts/hash_artifacts.py

      # 2) Verify artifacts & build badge JSON
      - name: Verify artifacts and build badge JSON
        run: |
          set -euo pipefail
          python - <<'PY'
          import os, json, hashlib, pathlib

          ART_ROOT = pathlib.Path("artifacts")
          BADGE_DIR = pathlib.Path("badges")
          BADGE_DIR.mkdir(parents=True, exist_ok=True)
          badge_path = BADGE_DIR / "artifacts.json"

          # Extensions treated as "real" artifacts for verification
          exts = {
              ".wav", ".flac", ".mp3", ".m4a", ".aiff",
              ".png", ".jpg", ".jpeg", ".gif", ".webp",
              ".tif", ".tiff",
              ".pdf", ".txt", ".csv", ".json",
          }

          def short_sha256(path: pathlib.Path, n: int = 12) -> str:
              h = hashlib.sha256()
              with path.open("rb") as f:
                  for chunk in iter(lambda: f.read(8192), b""):
                      h.update(chunk)
              return h.hexdigest()[:n]

          def load_declared_hashes(meta_file: pathlib.Path) -> dict:
              try:
                  j = json.loads(meta_file.read_text("utf-8"))
              except Exception:
                  return {}
              if isinstance(j, list):
                  items = j
              elif isinstance(j, dict):
                  for key in ("files", "items", "entries", "artifacts"):
                      if isinstance(j.get(key), list):
                          items = j[key]
                          break
                  else:
                      return {}
              else:
                  return {}
              out = {}
              for it in items:
                  rel = it.get("file") or it.get("path")
                  sha = it.get("sha") or it.get("sha256")
                  if rel and sha:
                      out[str(rel)] = str(sha).strip()
              return out

          total_files = checked = mismatches = declared_total = folders = 0

          if ART_ROOT.exists():
              for sub in sorted(ART_ROOT.glob("*")):
                  if not sub.is_dir():
                      continue
                  folders += 1

                  actual = []
                  for root, _, files in os.walk(sub):
                      for fname in files:
                          if fname.startswith("."):
                              continue
                          p = pathlib.Path(root) / fname
                          if p.suffix.lower() in exts:
                              actual.append(p)
                  total_files += len(actual)

                  declared = {}
                  meta = sub / "metadata.json"
                  if meta.exists():
                      declared = load_declared_hashes(meta)
                      declared_total += len(declared)

                  for p in actual:
                      rel_from_art = str(p.relative_to(ART_ROOT))
                      sha_now = short_sha256(p, 12)
                      checked += 1
                      if declared:
                          sha_decl = declared.get(rel_from_art)
                          ok = (sha_decl == sha_now) or (
                              isinstance(sha_decl, str) and sha_decl.startswith(sha_now)
                          )
                          if not ok:
                              mismatches += 1

          if total_files == 0:
              badge = {
                  "schemaVersion": 1,
                  "label": "artifacts",
                  "message": "none",
                  "color": "inactive",
              }
          elif mismatches == 0:
              msg = (
                  f"verified • {checked} files"
                  if declared_total
                  else f"hashed • {checked} files"
              )
              badge = {
                  "schemaVersion": 1,
                  "label": "artifacts",
                  "message": msg,
                  "color": "success",
              }
          else:
              badge = {
                  "schemaVersion": 1,
                  "label": "artifacts",
                  "message": f"mismatch • {mismatches}",
                  "color": "critical",
              }

          badge_path.write_text(
              json.dumps(badge, ensure_ascii=False),
              encoding="utf-8",
          )
          print("Wrote badge JSON →", badge_path)
          print(
              f"folders={folders} total_files={total_files} "
              f"checked={checked} declared={declared_total} "
              f"mismatches={mismatches}"
          )
          PY

      # 3) Commit & safe push (metadata + checksums + badge)
      - name: Commit & safe push (rebase + retry)
        run: |
          set -euo pipefail

          git config user.name  "${GIT_AUTHOR_NAME}"
          git config user.email "${GIT_AUTHOR_EMAIL}"

          # Add metadata, checksum files, and the badge JSON if present
          git add artifacts/**/metadata.json artifacts/**/SHA256SUMS.txt badges/artifacts.json 2>/dev/null || true

          if git diff --cached --quiet; then
            echo "No artifact-related changes to commit."
            exit 0
          fi

          git commit -m "chore(artifacts): update checksums, metadata & badge"

          git fetch origin main

          for n in 1 2 3; do
            git pull --rebase origin main || true
            if git push "https://x-access-token:${HF_PAT}@github.com/${{ github.repository }}.git" HEAD:main; then
              exit 0
            fi
            echo "Push attempt $n failed; retrying..."
            sleep 2
          done

          echo "Push failed after retries" >&2
          exit 1