name: Verify Artifacts & Publish Badge

on:
  push:
    paths:
      - "artifacts/**"
      - "scripts/**"
      - ".github/workflows/verify-artifacts.yml"
  schedule:
    - cron: "23 3 * * *"   # nightly
  workflow_dispatch: {}

permissions:
  contents: write

jobs:
  verify:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Verify artifacts and build badge JSON
        id: verify
        run: |
          python - <<'PY'
          import os, json, hashlib, pathlib

          ART_ROOT = pathlib.Path("artifacts")
          BADGE_DIR = pathlib.Path("badges")
          BADGE_DIR.mkdir(parents=True, exist_ok=True)
          badge_path = BADGE_DIR / "artifacts.json"

          exts = {".wav",".flac",".mp3",".m4a",".aiff",
                  ".png",".jpg",".jpeg",".gif",".webp",
                  ".pdf",".txt",".json"}  # extend as needed

          def short_sha256(path: pathlib.Path, n=12) -> str:
              h = hashlib.sha256()
              with path.open("rb") as f:
                  for chunk in iter(lambda: f.read(8192), b""):
                      h.update(chunk)
              return h.hexdigest()[:n]

          def load_declared_hashes(meta_file: pathlib.Path) -> dict:
              """
              Try to read hashes from artifacts/*/metadata.json if present.
              Flexible on schema:
              - [{"file": "...", "sha": "..."}]
              - {"files":[{"path": "...", "sha256": "..."}]}
              - {"items":[...]}  with "file" or "path", "sha"/"sha256"
              Returns {relative_path_from_artifacts: sha_string}
              """
              try:
                  j = json.loads(meta_file.read_text("utf-8"))
              except Exception:
                  return {}

              # normalize to a flat list of entries
              if isinstance(j, list):
                  items = j
              elif isinstance(j, dict):
                  for key in ("files","items","entries"):
                      if isinstance(j.get(key), list):
                          items = j[key]
                          break
                  else:
                      # single-file style (just describes metadata.json itself)
                      return {}
              else:
                  return {}

              out = {}
              for it in items:
                  rel = it.get("file") or it.get("path")
                  if not rel: 
                      continue
                  sha = it.get("sha") or it.get("sha256")
                  if not sha:
                      continue
                  out[rel] = str(sha).strip()
              return out

          total_files = 0
          checked = 0
          mismatches = 0
          declared_total = 0
          folders = 0

          for sub in sorted(ART_ROOT.glob("*")):
              if not sub.is_dir():
                  continue
              folders += 1

              # Discover files we *actually* have (filter by extensions)
              actual = []
              for root, _, files in os.walk(sub):
                  for fname in files:
                      if fname.startswith("."):
                          continue
                      p = pathlib.Path(root) / fname
                      if p.suffix.lower() in exts:
                          actual.append(p)
              total_files += len(actual)

              # Try to load declared hashes (if any)
              declared = {}
              meta = sub / "metadata.json"
              if meta.exists():
                  declared = load_declared_hashes(meta)
                  declared_total += len(declared)

              # Compare
              for p in actual:
                  rel_from_art = str(p.relative_to(ART_ROOT))
                  sha_now = short_sha256(p, 12)
                  checked += 1

                  if declared:
                      sha_decl = declared.get(rel_from_art)
                      # accept either exact match or prefix-match (handles 12-char vs full length)
                      ok = (sha_decl == sha_now) or (isinstance(sha_decl, str) and sha_decl.startswith(sha_now))
                      if not ok:
                          mismatches += 1

          # Badge content
          if total_files == 0:
              badge = {
                "schemaVersion": 1,
                "label": "artifacts",
                "message": "none",
                "color": "inactive"
              }
            # no files at all
          elif mismatches == 0:
              msg = f"verified • {checked} files"
              if declared_total == 0:
                  msg = f"hashed • {checked} files"
              badge = {
                "schemaVersion": 1,
                "label": "artifacts",
                "message": msg,
                "color": "success"
              }
          else:
              badge = {
                "schemaVersion": 1,
                "label": "artifacts",
                "message": f"mismatch • {mismatches}",
                "color": "critical"
              }

          badge_path.write_text(json.dumps(badge, ensure_ascii=False), encoding="utf-8")
          print("Wrote badge JSON →", badge_path)

          # Surface a short summary in logs
          print(f"folders={folders} total_files={total_files} checked={checked} declared={declared_total} mismatches={mismatches}")
          PY

      - name: Commit badge (if changed)
        run: |
          git config user.name  "Finch Bot"
          git config user.email "actions@github.com"
          git add badges/artifacts.json || true
          if ! git diff --cached --quiet; then
            git commit -m "chore(badge): update artifacts verification badge"
            git push
          else
            echo "No badge change to commit."
          fi
